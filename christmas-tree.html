<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Christmas Tree - Magic Gallery</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; }
        
        #meteor-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 215, 0, 0.3);
            z-index: 10;
            background: #000;
            transform: scaleX(-1);
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        #video-container:hover { opacity: 1; }
        video { width: 100%; height: 100%; object-fit: cover; }

        .btn-group {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
            align-items: center;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        .control-btn:hover { background: rgba(255, 215, 0, 0.3); transform: scale(1.1); color: #ffd700; }
        
        #upload-label {
            width: auto;
            padding: 0 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            text-align: center;
            z-index: 20;
            transition: opacity 0.5s;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255,215,0,0.3);
            border-top: 4px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .status-text { font-size: 14px; color: #aaa; margin-top: 5px; }
        #file-input { display: none; }
        
        #gesture-hint {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            z-index: 5;
        }

        #music-btn.playing {
            color: #ffd700;
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            animation: musicPulse 2s infinite;
        }
        @keyframes musicPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>

    <!-- Mediapipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div>È≠îÊ≥ïÊ≠£Âú®Âä†ËΩΩ...</div>
        <div class="status-text">ËØ∑ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥ÊùÉÈôê</div>
    </div>

    <div id="gesture-hint">üñê Âº†ÂºÄÊâãÔºöÁàÜÁÇ∏+ÊµÅÊòü | üëå ÊçèÂêàÔºöÊäΩÂèñÁÖßÁâá</div>
    
    <canvas id="meteor-canvas"></canvas>

    <div id="video-container">
        <video class="input_video" playsinline></video>
    </div>
    
    <div class="btn-group">
        <audio id="bgm" loop>
            <source src="https://music.163.com/song/media/outer/url?id=1496089312.mp3" type="audio/mpeg">
        </audio>
        <button id="music-btn" class="control-btn" title="Êí≠Êîæ/ÊöÇÂÅúÈü≥‰πê">‚ô´</button>

        <label for="file-input" id="upload-label" class="control-btn">
            <span>üì∑ ‰∏ä‰º†ÁÖßÁâá</span>
        </label>
        <input type="file" id="file-input" accept="image/*" multiple>
        <button id="fullscreen-btn" class="control-btn" title="ÂÖ®Â±è">‚õ∂</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ================= ÈÖçÁΩÆ =================
        const CONFIG = {
            treeTotalInstances: 2200, 
            sparkleCount: 1200, 
            bloomStrength: 1.0, 
            handState: 'Êú™Ê£ÄÊµã',
            gestureScale: 1.0, 
            photoSize: 3.5
        };

        // ÂÖ®Â±ÄÈÄªËæëÂèòÈáè
        let isPinching = false;
        let pinchTargetIndex = -1;
        let lastPinchIndex = -1; 
        
        let smoothHandOpenDist = 0.0;
        let pinchTriggered = false; 
        let currentTargetScale = 1.0; 
        let handOffsetX = 0;
        let handOffsetY = 0;

        // ================= 1. 2D Canvas ÊµÅÊòüÁ≥ªÁªü =================
        const canvas = document.getElementById('meteor-canvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        class Meteor {
            constructor() {
                this.reset(true); 
            }

            reset(initial = false) {
                const w = canvas.width;
                const h = canvas.height;
                this.angle = Math.PI / 4 + Math.random() * (Math.PI / 12); 
                this.speed = 6 + Math.random() * 10;
                this.length = 50 + Math.random() * 150;
                this.width = 1 + Math.random() * 2;
                
                const colors = [
                    { h: 210, s: 80, l: 80 }, 
                    { h: 260, s: 70, l: 85 }, 
                    { h: 0, s: 0, l: 100 }    
                ];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                
                this.opacity = 0;
                this.fadeIn = true;
                this.maxOpacity = 0.6 + Math.random() * 0.4;
                this.flickerOffset = Math.random() * 100;

                this.delay = initial ? Math.random() * 100 : Math.random() * 200; 
                this.active = false;
                this.x = Math.random() * w + w * 0.2;
                this.y = -Math.random() * h * 0.5;
            }

            update() {
                if (this.delay > 0) {
                    this.delay--;
                    if (this.delay <= 0) this.active = true;
                    return;
                }
                if (!this.active) return;

                this.x -= this.speed * Math.cos(this.angle);
                this.y += this.speed * Math.sin(this.angle);

                if (this.fadeIn) {
                    this.opacity += 0.05;
                    if (this.opacity >= this.maxOpacity) {
                        this.opacity = this.maxOpacity;
                        this.fadeIn = false;
                    }
                }

                if (this.x < -this.length || this.y > canvas.height + this.length) {
                    this.reset();
                }
            }

            draw(ctx, frameCount) {
                if (!this.active || this.delay > 0) return;

                const headX = this.x;
                const headY = this.y;
                const tailX = this.x + this.length * Math.cos(this.angle);
                const tailY = this.y - this.length * Math.sin(this.angle);

                const flicker = 0.7 + 0.3 * Math.sin((frameCount + this.flickerOffset) * 0.5);
                
                const gradient = ctx.createLinearGradient(headX, headY, tailX, tailY);
                gradient.addColorStop(0, `hsla(${this.color.h}, ${this.color.s}%, ${this.color.l}%, ${this.opacity})`);
                gradient.addColorStop(0.3, `hsla(${this.color.h}, ${this.color.s}%, ${this.color.l}%, ${this.opacity * 0.5})`);
                gradient.addColorStop(1, `hsla(${this.color.h}, ${this.color.s}%, ${this.color.l}%, 0)`);

                ctx.save();
                ctx.beginPath();
                ctx.moveTo(headX, headY);
                ctx.lineTo(tailX, tailY);
                ctx.lineWidth = this.width;
                ctx.lineCap = 'round';
                ctx.strokeStyle = gradient;
                
                ctx.shadowBlur = 15 * flicker;
                ctx.shadowColor = `hsla(${this.color.h}, ${this.color.s}%, 95%, ${this.opacity})`;
                
                ctx.stroke();
                ctx.restore();
            }
        }

        const meteorSystem = [];
        const MAX_METEORS = 12; 
        for (let i = 0; i < MAX_METEORS; i++) {
            meteorSystem.push(new Meteor());
        }

        // ================= 2. Three.js Âú∫ÊôØÂàùÂßãÂåñ =================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 45);
        scene.add(camera); 

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, // ÂºÄÂêØÊäóÈîØÈΩøËß£ÂÜ≥ÈîØÈΩø
            powerPreference: "high-performance" 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0; 
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); 
        scene.add(ambientLight);
        const mainLight = new THREE.DirectionalLight(0xffffff, 2.0);
        mainLight.position.set(10, 20, 10);
        scene.add(mainLight);

        scene.add(new THREE.PointLight(0xffd700, 2.0, 60)); 
        scene.add(new THREE.PointLight(0x00ffff, 1.5, 60)); 
        scene.add(new THREE.PointLight(0xff0044, 1.5, 60));

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // ÈòàÂÄºÊèêÈ´òÂà∞ 0.85Ôºå‰øùËØÅÊôÆÈÄöÁÖßÁâá‰∏çÂèëÂÖâ
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.85; 
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // ================= 3. ÂÆû‰ΩìÂá†‰Ωï‰ΩìÁ≥ªÁªü =================
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        const commonMatProps = { roughness: 0.2, metalness: 0.8 };
        const sphereMat = new THREE.MeshStandardMaterial({ 
            ...commonMatProps, 
            color: 0xffffff,
            emissive: 0x222222 
        });
        const cubeMat = new THREE.MeshStandardMaterial({ 
            ...commonMatProps, 
            color: 0xffffff,
            emissive: 0x222222
        });
        
        // Èì∂Ëâ≤Á≤íÂ≠êÈ´ò‰∫ÆÂ∫¶‰ª•Ëß¶ÂèëBloom
        const sparkleMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0xffffff, 
            emissiveIntensity: 5.0, 
            roughness: 0.0,
            metalness: 1.0
        });

        const sphereGeo = new THREE.SphereGeometry(0.35, 16, 16);
        const cubeGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55);
        const sparkleGeo = new THREE.OctahedronGeometry(0.05, 0); 

        const sphereMaxCount = Math.ceil(CONFIG.treeTotalInstances * 0.6);
        const cubeMaxCount = CONFIG.treeTotalInstances - sphereMaxCount;
        
        const sphereMesh = new THREE.InstancedMesh(sphereGeo, sphereMat, sphereMaxCount);
        const cubeMesh = new THREE.InstancedMesh(cubeGeo, cubeMat, cubeMaxCount);
        const sparkleMesh = new THREE.InstancedMesh(sparkleGeo, sparkleMat, CONFIG.sparkleCount);
        
        treeGroup.add(sphereMesh);
        treeGroup.add(cubeMesh);
        treeGroup.add(sparkleMesh);

        function createStarGeometry(radius = 1.5, thickness = 0.5) {
            const shape = new THREE.Shape();
            const points = 5;
            for (let i = 0; i < points * 2; i++) {
                const l = i % 2 === 0 ? radius : radius * 0.45;
                const a = i / points * Math.PI;
                shape.lineTo(Math.sin(a + Math.PI*1.5) * l, Math.cos(a + Math.PI*1.5) * l);
            }
            return new THREE.ExtrudeGeometry(shape, { steps: 1, depth: thickness, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 1 });
        }
        const star = new THREE.Mesh(createStarGeometry(1.8, 0.4), new THREE.MeshStandardMaterial({ 
            color: 0xffd700, 
            emissive: 0xffaa00, 
            emissiveIntensity: 3.0, 
            metalness: 1.0, 
            roughness: 0.1 
        }));
        treeGroup.add(star);

        const treeInstances = [];
        const h = 40; 
        
        function initTreeData() {
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            star.position.set(0, h/2 + 1.5, 0);
            
            let sIdx = 0, cIdx = 0;

            for (let i = 0; i < CONFIG.treeTotalInstances; i++) {
                const wantSphere = Math.random() < 0.6;
                const isSphere = (wantSphere && sIdx < sphereMaxCount) || (cIdx >= cubeMaxCount);
                const mesh = isSphere ? sphereMesh : cubeMesh;
                const index = isSphere ? sIdx++ : cIdx++;
                generateInstanceData(mesh, index, i, CONFIG.treeTotalInstances, false);
            }

            for (let i = 0; i < CONFIG.sparkleCount; i++) {
                generateInstanceData(sparkleMesh, i, i, CONFIG.sparkleCount, true);
            }

            sphereMesh.instanceMatrix.needsUpdate = true;
            cubeMesh.instanceMatrix.needsUpdate = true;
            sparkleMesh.instanceMatrix.needsUpdate = true;
        }

        function generateInstanceData(mesh, index, i, total, isSparkle) {
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();

            const p = i / total;
            const y = (p * h) - h/2;
            let rRand = (h/2 - y) * 0.5 + (Math.random() - 0.5) * 3;
            if(isSparkle) rRand += (Math.random() * 4.0 - 1.0); 
            
            const angle = y * 2.5 + (i * 0.1) + (isSparkle ? Math.random() * 50 : 0);
            const tx = Math.cos(angle) * rRand;
            const tz = Math.sin(angle) * rRand;

            const sr = 22 + (Math.random()-0.5) * 8 + (isSparkle ? 5 : 0);
            const sPhi = Math.acos(2 * Math.random() - 1);
            const sTheta = Math.random() * Math.PI * 2;
            const sx = sr * Math.sin(sPhi) * Math.cos(sTheta);
            const sy = sr * Math.sin(sPhi) * Math.sin(sTheta);
            const sz = sr * Math.cos(sPhi);

            if (!isSparkle) {
                const baseColor = new THREE.Color();
                if (mesh === sphereMesh) baseColor.setHex(Math.random() > 0.4 ? 0xffd700 : 0xd41515);
                else {
                    const r = Math.random();
                    if (r < 0.65) baseColor.setHex(0xc41e3a); else if (r < 0.9) baseColor.setHex(0x006400); else baseColor.setHex(0xffd700);
                }
                mesh.setColorAt(index, baseColor);
            }

            dummy.position.set(tx, y, tz);
            dummy.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
            dummy.updateMatrix();
            mesh.setMatrixAt(index, dummy.matrix);

            treeInstances.push({
                type: isSparkle ? 'sparkle' : 'normal',
                mesh: mesh, index: index,
                posTree: new THREE.Vector3(tx, y, tz),
                posSphere: new THREE.Vector3(sx, sy, sz),
                rotation: new THREE.Euler(Math.random(), Math.random(), Math.random()),
                phaseOffset: Math.random() * Math.PI * 2 
            });
        }
        initTreeData();

        // ================= 4. ÁÖßÁâáÂ¢ôÈÄªËæë =================
        const photoGroup = new THREE.Group();
        treeGroup.add(photoGroup);
        const photoObjects = [];
        const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, roughness: 0.8 });

        document.getElementById('file-input').addEventListener('change', handleImageUpload);

        function handleImageUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            while(photoGroup.children.length > 0) photoGroup.remove(photoGroup.children[0]);
            photoObjects.length = 0;
            lastPinchIndex = -1; 

            Array.from(files).forEach((file, i) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => createPhotoMesh(img, i, files.length);
                };
                reader.readAsDataURL(file);
            });
        }

        function createPhotoMesh(image, index, total) {
            const texture = new THREE.Texture(image);
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.needsUpdate = true;

            const aspect = image.width / image.height;
            const width = CONFIG.photoSize;
            const height = width / aspect;

            const geometry = new THREE.PlaneGeometry(width, height);
            
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                toneMapped: true // ÂàùÂßãÂºÄÂêØ
            });
            const mesh = new THREE.Mesh(geometry, material);

            const frameMesh = new THREE.Mesh(new THREE.BoxGeometry(width + 0.4, height + 0.4, 0.2), woodMaterial);
            frameMesh.position.z = -0.11;
            frameMesh.visible = false; 
            mesh.add(frameMesh);
            photoGroup.add(mesh);

            const p = (index + 0.5) / total;
            const y = (p * (h - 10)) - (h/2 - 5);
            const r = (h/2 - y) * 0.5 + 1.5;
            const angle = index * 2.4;
            const tx = Math.cos(angle) * r;
            const tz = Math.sin(angle) * r;

            mesh.position.set(tx, y, tz);
            mesh.lookAt(0, y, 0);
            mesh.rotateY(Math.PI);

            const sr = 25;
            const sPhi = Math.acos(2 * Math.random() - 1);
            const sTheta = Math.random() * Math.PI * 2;
            const sx = sr * Math.sin(sPhi) * Math.cos(sTheta);
            const sy = sr * Math.sin(sPhi) * Math.sin(sTheta);
            const sz = sr * Math.cos(sPhi);

            photoObjects.push({
                mesh: mesh,
                frame: frameMesh,
                posTree: new THREE.Vector3(tx, y, tz),
                posSphere: new THREE.Vector3(sx, sy, sz),
                rotationStart: mesh.rotation.clone(),
            });
        }

        // ================= 5. Èü≥‰πêÈÄªËæë =================
        const audioEl = document.getElementById('bgm');
        const musicBtn = document.getElementById('music-btn');
        let isMusicPlaying = false;

        function toggleMusic() {
            if (isMusicPlaying) {
                audioEl.pause();
                musicBtn.classList.remove('playing');
                musicBtn.style.color = 'white';
            } else {
                const playPromise = audioEl.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        musicBtn.classList.add('playing');
                        isMusicPlaying = true;
                    }).catch(error => {
                        console.log("Èü≥È¢ëÊí≠ÊîæÂèóÈòª:", error);
                        alert("ËØ∑ÁÇπÂáªÈ°µÈù¢ËøõË°å‰∫§‰∫í‰ª•Êí≠ÊîæÈü≥‰πê");
                    });
                }
            }
            isMusicPlaying = !isMusicPlaying;
        }
        
        musicBtn.addEventListener('click', toggleMusic);
        
        // ================= ÊâãÂäøËØÜÂà´ =================
        const videoElement = document.getElementsByClassName('input_video')[0];
        
        function onResults(results) {
            document.getElementById('loader').style.display = 'none';
            
            let detected = false;
            let rawPinchDist = 0;
            let rawHandOpenDist = 0;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                detected = true;
                const lm = results.multiHandLandmarks[0];
                const wrist = lm[0];
                
                rawPinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                const tips = [4, 8, 12, 16, 20];
                let totalDist = 0;
                tips.forEach(idx => totalDist += Math.hypot(lm[idx].x - wrist.x, lm[idx].y - wrist.y));
                rawHandOpenDist = totalDist / 5;
            }

            if (detected) {
                smoothHandOpenDist = smoothHandOpenDist * 0.9 + rawHandOpenDist * 0.1;
                const pinchInThreshold = 0.04;
                const pinchOutThreshold = 0.08;

                if (rawPinchDist < pinchInThreshold) pinchTriggered = true;
                else if (rawPinchDist > pinchOutThreshold) pinchTriggered = false;

                if (pinchTriggered) {
                    CONFIG.handState = "üëå ÊçèÂêà (ÈÄâ‰∏≠ÁÖßÁâá)";
                    if (!isPinching) {
                        isPinching = true;
                        if (photoObjects.length > 0) {
                            let newIndex;
                            if (photoObjects.length === 1) newIndex = 0;
                            else {
                                do { newIndex = Math.floor(Math.random() * photoObjects.length); } while (newIndex === lastPinchIndex);
                            }
                            pinchTargetIndex = newIndex;
                            lastPinchIndex = newIndex;
                        }
                    }
                } else {
                    isPinching = false;
                    pinchTargetIndex = -1;

                    if (smoothHandOpenDist > 0.25) { 
                        CONFIG.handState = "üñê Âº†ÂºÄ (ÁàÜÁÇ∏+ÊµÅÊòü)";
                        let suggestedScale = 1.2 + (smoothHandOpenDist - 0.25) * 5.0; 
                        suggestedScale = Math.min(Math.max(suggestedScale, 1.2), 2.5);
                        if (Math.abs(suggestedScale - currentTargetScale) > 0.05) {
                            currentTargetScale = suggestedScale;
                        }
                    } else {
                        CONFIG.handState = "‚úä Êè°Êã≥/Ëá™ÁÑ∂ (Ê†ë)";
                        currentTargetScale = 1.0;
                    }
                }
            } else {
                CONFIG.handState = "Êú™Ê£ÄÊµã";
                currentTargetScale = 1.0;
                isPinching = false;
                pinchTriggered = false;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        // ================= Âä®ÁîªÂæ™ÁéØ =================
        const dummy = new THREE.Object3D();
        const clock = new THREE.Clock();
        let frameCount = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            const time = clock.getElapsedTime();

            CONFIG.gestureScale = THREE.MathUtils.lerp(CONFIG.gestureScale, currentTargetScale, 0.05);
            controls.autoRotate = CONFIG.autoRotate;
            controls.update();

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const showMeteors = CONFIG.gestureScale > 1.2;
            if (showMeteors) {
                meteorSystem.forEach(meteor => {
                    meteor.update();
                    meteor.draw(ctx, frameCount);
                });
            }

            if (CONFIG.mode === 'Âú£ËØûÊ†ë') {
                particleSystem.visible = false;
                treeGroup.visible = true;
                star.rotation.y += 0.015;

                const morphProgress = THREE.MathUtils.smoothstep(CONFIG.gestureScale, 1.0, 1.6);
                const finalScale = morphProgress > 0.5 ? 1.0 + (CONFIG.gestureScale - 1.0) * 0.3 : CONFIG.gestureScale;

                for (let i = 0; i < treeInstances.length; i++) {
                    const data = treeInstances[i];
                    const cx = THREE.MathUtils.lerp(data.posTree.x, data.posSphere.x, morphProgress);
                    const cy = THREE.MathUtils.lerp(data.posTree.y, data.posSphere.y, morphProgress);
                    const cz = THREE.MathUtils.lerp(data.posTree.z, data.posSphere.z, morphProgress);
                    
                    dummy.position.set(cx * finalScale, cy * finalScale, cz * finalScale);
                    dummy.rotation.copy(data.rotation);
                    
                    if (data.type === 'sparkle') {
                        const localTime = time + data.phaseOffset;
                        const blink = (Math.sin(localTime * Math.PI * 2.5) + 1) * 0.5; 
                        let s = blink > 0.8 ? 2.0 : 0.5; 
                        dummy.scale.setScalar(s);
                    } else {
                        dummy.scale.setScalar(1);
                    }
                    dummy.updateMatrix();
                    data.mesh.setMatrixAt(data.index, dummy.matrix);
                }
                
                sphereMesh.instanceMatrix.needsUpdate = true;
                cubeMesh.instanceMatrix.needsUpdate = true;
                sparkleMesh.instanceMatrix.needsUpdate = true;

                // --- ÂÖ≥ÈîÆ‰øÆÊ≠£ÔºöÁÖßÁâá‰ΩçÁΩÆ‰∏éËßíÂ∫¶ ---
                
                // 1. ËÆ°ÁÆó„ÄêÂ±èÂπïÊ≠£‰∏≠Â§Æ„ÄëÂØπÂ∫îÁöÑ3DÁ©∫Èó¥‰ΩçÁΩÆ
                // Âú®Áõ∏Êú∫ÂùêÊ†áÁ≥ª‰∏ãÔºå(0,0,-15) Â∞±ÊòØÁõ∏Êú∫Ê≠£ÂâçÊñπ15Âçï‰ΩçÁöÑ‰ΩçÁΩÆÔºå‰πüÂ∞±ÊòØÂ±èÂπïÊ≠£‰∏≠Â§Æ
                const screenCenterPos = new THREE.Vector3(0, 0, -15);
                screenCenterPos.applyMatrix4(camera.matrixWorld); // ËΩ¨Êç¢‰∏∫‰∏ñÁïåÂùêÊ†á
                
                photoObjects.forEach((obj, idx) => {
                    const isFocused = (isPinching && idx === pinchTargetIndex);

                    if (isFocused) {
                        // === ÈÄâ‰∏≠Áä∂ÊÄÅ ===
                        if (obj.mesh.parent !== scene) {
                            scene.attach(obj.mesh);
                            obj.mesh.material.toneMapped = false;
                            obj.mesh.material.color.setScalar(1.0); 
                            obj.mesh.material.needsUpdate = true;
                        }

                        // 2. ‰ΩçÁΩÆÔºöÊèíÂÄºÂà∞Â±èÂπïÊ≠£‰∏≠Â§Æ
                        obj.mesh.position.lerp(screenCenterPos, 0.1);
                        
                        // 3. ËßíÂ∫¶Ôºö‰∏éÁõ∏Êú∫ÂÆåÂÖ®Âπ≥Ë°å (SlerpÂà∞Áõ∏Êú∫ÁöÑÊóãËΩ¨ÂõõÂÖÉÊï∞)
                        // Ëøô‰øùËØÅ‰∫ÜÂõæÁâáÊ≠£Èù¢ÊúùÂêëÂ±èÂπïÔºå‰∏î‰∏ä‰∏ãÂ∑¶Âè≥ËæπÁºòÂπ≥Ë°å‰∫éÂ±èÂπïËæπÁºò
                        obj.mesh.quaternion.slerp(camera.quaternion, 0.1);

                        obj.mesh.scale.lerp(new THREE.Vector3(2.5, 2.5, 2.5), 0.1);
                        obj.frame.visible = true;

                    } else {
                        // === ÂΩí‰Ωç ===
                        if (obj.mesh.parent === scene) {
                            photoGroup.attach(obj.mesh);
                            obj.mesh.material.toneMapped = true;
                            obj.mesh.material.color.setScalar(1.0); 
                            obj.mesh.material.needsUpdate = true;
                        }

                        const tx = THREE.MathUtils.lerp(obj.posTree.x, obj.posSphere.x, morphProgress);
                        const ty = THREE.MathUtils.lerp(obj.posTree.y, obj.posSphere.y, morphProgress);
                        const tz = THREE.MathUtils.lerp(obj.posTree.z, obj.posSphere.z, morphProgress);
                        
                        obj.mesh.position.lerp(new THREE.Vector3(tx * finalScale, ty * finalScale, tz * finalScale), 0.1);
                        obj.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                        obj.frame.visible = false;

                        if (morphProgress < 0.1) {
                            obj.mesh.rotation.x = THREE.MathUtils.lerp(obj.mesh.rotation.x, obj.rotationStart.x, 0.1);
                            obj.mesh.rotation.y = THREE.MathUtils.lerp(obj.mesh.rotation.y, obj.rotationStart.y, 0.1);
                            obj.mesh.rotation.z = THREE.MathUtils.lerp(obj.mesh.rotation.z, obj.rotationStart.z, 0.1);
                        } else {
                            obj.mesh.lookAt(0, 0, 0);
                            obj.mesh.rotateY(Math.PI);
                        }
                    }
                });

            } else {
                particleSystem.visible = true;
                treeGroup.visible = false;
            }
            composer.render();
        }

        const gui = new GUI({ title: 'È≠îÊ≥ïÊéßÂà∂Âè∞' });
        gui.add(CONFIG, 'mode', MODES).onChange(v => {
            CONFIG.mode = v;
            bloomPass.strength = v === 'Âú£ËØûÊ†ë' ? 1.0 : 1.8;
            if(v !== 'Âú£ËØûÊ†ë') updateParticleShape(v);
        });
        gui.add(CONFIG, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        });

        animate();
    </script>
</body>
</html>